<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core"#>
<#@ assembly name="EnvDTE"#>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\..\T4 Tools\MultipleOutputHelper.ttinclude"#>
<#@ output extension="/" #>
<#
    var manager = Manager.Create(Host, GenerationEnvironment);
    var types = new[] { "int", "uint" };
    var names = new[] { "Int", "UInt" };

    for (int i = 0; i < types.Length; ++i)
    {
        var typeName = types[i];
        var fileName = string.Format("Range{0}", names[i]);
        var className= fileName;
        manager.StartNewFile(string.Format("{0}.cs", fileName));
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a T4 template.
//
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace <#=string.Format("{0}{1}{2}", manager.DefaultProjectNamespace,
    string.IsNullOrEmpty(manager.GetCustomToolNamespace(Host.TemplateFile)) ?
        string.Empty : ".", manager.GetCustomToolNamespace(Host.TemplateFile))#>
{
    public class <#=className#>
    {
        private Tuple<<#=typeName#>, <#=typeName#>> _Range;

        public static readonly <#=className#> Void = new <#=className#>(default(<#=typeName#>), default(<#=typeName#>));

        public <#=typeName#> Minimum { get { return _Range.Item1; } }

        public <#=typeName#> Maximum { get { return _Range.Item2; } }

        public <#=typeName#> Count { get { return Maximum - Minimum + 1; } }

        public <#=className#>(<#=typeName#> min, <#=typeName#> max)
        {
            _Range = new Tuple<<#=typeName#>, <#=typeName#>>(min, max);
        }

        public bool ContainsValue(<#=typeName#> value)
        {
			return Comparer<<#=typeName#>>.Default.Compare(Minimum, value) <= 0 &&
                Comparer<<#=typeName#>>.Default.Compare(value, Maximum) <= 0;
        }

        public bool IsInsideRange(<#=className#> range) =>
            range.ContainsValue(Minimum) && range.ContainsValue(Maximum);

        public bool ContainsRange(<#=className#> range) =>
            ContainsValue(range.Minimum) && ContainsValue(range.Maximum);

        public bool IsOverlapping(<#=className#> range) =>
            ContainsValue(range.Minimum) || ContainsValue(range.Maximum) ||
            range.ContainsValue(Minimum) || range.ContainsValue(Maximum);

		public <#=className#> Union(<#=className#> range)
        {
            if (!IsOverlapping(range))
                return Void;
            if (IsInsideRange(range))
                return range;
            if (ContainsRange(range))
                return this;
            return new <#=className#>(
                Comparer<<#=typeName#>>.Default.Compare(Minimum, range.Minimum) < 0 ?
                    Minimum : range.Minimum,
                Comparer<<#=typeName#>>.Default.Compare(Maximum, range.Maximum) > 0 ?
                    Maximum : range.Maximum);
        }

        public <#=className#> Intersect(<#=className#> range)
        {
            if (!IsOverlapping(range))
                return Void;
            if (IsInsideRange(range))
                return this;
            if (ContainsRange(range))
                return range;
            return new <#=className#>(
                Comparer<<#=typeName#>>.Default.Compare(Minimum, range.Minimum) < 0 ?
                    range.Minimum : Minimum,
                Comparer<<#=typeName#>>.Default.Compare(Maximum, range.Maximum) > 0 ?
                    range.Maximum : Maximum);
        }
    }
}
<#
    }
    manager.Process(true);
#>